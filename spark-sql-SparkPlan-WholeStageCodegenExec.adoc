== [[WholeStageCodegenExec]] WholeStageCodegenExec Unary Operator with Java Code Generation

`WholeStageCodegenExec` is a link:spark-sql-SparkPlan.adoc#UnaryExecNode[unary physical operator] that link:spark-sql-CodegenSupport.adoc[supports code generation] to produce a *codegened pipeline* for a child physical operator.

`WholeStageCodegenExec` is created when link:spark-sql-whole-stage-codegen.adoc#CollapseCodegenStages[CollapseCodegenStages] physical optimization rule transforms when link:spark-sql-settings.adoc#spark.sql.codegen.wholeStage[spark.sql.codegen.wholeStage] is enabled.

NOTE: link:spark-sql-settings.adoc#spark.sql.codegen.wholeStage[spark.sql.codegen.wholeStage] property is enabled by default.

TIP: Use link:spark-sql-Dataset.adoc#explain[Dataset.explain] method to know the physical plan of a query and find out whether or not `WholeStageCodegen` is in use.

[source, scala]
----
val q = spark.range(10).where('id === 4)
// Note the stars in the output that are for codegened operators
scala> q.explain
== Physical Plan ==
*Filter (id#0L = 4)
+- *Range (0, 10, step=1, splits=8)
----

TIP: Consider using link:spark-sql-debugging-execution.adoc[Debugging Query Execution facility] to deep dive into whole stage codegen.

[source, scala]
----
scala> q.queryExecution.debug.codegen
Found 1 WholeStageCodegen subtrees.
== Subtree 1 / 1 ==
*Filter (id#5L = 4)
+- *Range (0, 10, step=1, splits=8)
----

NOTE: link:spark-sql-SparkPlan.adoc[Physical plans] that support code generation extend link:spark-sql-CodegenSupport.adoc[CodegenSupport].

=== [[doExecute]] `doExecute` Method

CAUTION: FIXME

=== [[doCodeGen]] `doCodeGen` Method

[source, scala]
----
doCodeGen(): (CodegenContext, CodeAndComment)
----

CAUTION: FIXME

NOTE: `doCodeGen` is used when `WholeStageCodegenExec` <<doExecute, doExecute>> (and for link:spark-sql-debugging-execution.adoc#debugCodegen[debugCodegen]).
