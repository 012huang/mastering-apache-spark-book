== Spark Execution Model

[CAUTION]
====
Todos:

* Review `Job` class
* Review `ResultStage`
* `SparkEnv.get.closureSerializer.newInstance()`
* `SchedulableBuilder`
** FIFO
** Fair
====

Spark Deployment modes:

* *local*
* *cluster*
** link:spark-standalone.adoc[Spark Standalone]
** link:spark-yarn.adoc[Spark on YARN]
** link:spark-mesos.adoc[Spark on Mesos]

A *driver* is where the task scheduler lives and spawns tasks across workers. Tasks are spawned one by one for each stage and data partition.

A *worker* is where the executors live and tasks execute.

CAUTION: FIXME Diagram of a driver with workers as boxes.

Explain task execution in Spark and understand Spark’s underlying execution model.

New vocabulary often faced in Spark UI

link:spark-sparkcontext.adoc[When you create SparkContext], each worker starts an executor. This is a separate process (JVM), and it loads your jar, too. The executors connect back to your driver program. Now the driver can send them commands, like `flatMap`, `map` and `reduceByKey`. When the driver quits, the executors shut down.

A new process is not started for each step. A new process is started on each worker when the SparkContext is constructed.

A *task* is a command sent from the driver to an executor by serializing your `Function` object. The executor deserializes the command (this is possible because it has loaded your jar), and executes it on a partition. The communication uses Akka's actors.

Shortly speaking, an application in Spark is executed in three steps:

1. Create RDD graph, i.e. DAG (directed acyclic graph) of RDDs to represent entire computation.
1. Create stage graph, i.e. a DAG of stages that is a logical execution plan based on the RDD graph. Stages are created by breaking the RDD graph at shuffle boundaries.
1. Based on the plan, schedule and execute tasks on workers.

link:spark-examples-wordcount-spark-shell.adoc[In the WordCount example], the RDD graph is as follows:

file -> lines -> words -> per-word count -> global word count -> output

Based on this graph, two stages are created. The *stage* creation rule is based on the idea of *pipelining* as many link:spark-rdd.adoc[narrow transformations] as possible. RDD operations with "narrow" dependencies, like `map()` and `filter()`, are pipelined together into one set of tasks in each stage.

In the end, every stage will only have shuffle dependencies on other stages, and may compute multiple operations inside it.

In the WordCount example, the narrow transformation finishes at per-word count. Therefore, you get two stages:

* file -> lines -> words -> per-word count
* global word count -> output

Once stages are defined, Spark will generate tasks from stages. The first stage will create ShuffleMapTasks and the last stage will create ResultTasks because in the last stage, one action operation is included to produce results.

The number of tasks to be generated depends on how your files are distributed. Suppose that you have 3 three different files in three different nodes, the first stage will generate 3 tasks: one task per partition.

Therefore, you should not map your steps to tasks directly. A task belongs to a stage, and is related to a partition.

The number of tasks being generated in each stage will be equal to the number of partitions.

spark compute nodes


=== Master/slave architecture of Spark

Spark uses a *master/slave architecture*. It has a single coordinator, *driver* (also called *master*, internally), that communicates with one or more distributed workers, i.e. *executors*.

The driver and the executors run in their own Java processes. You can run them all on the same (_horizontal cluster_) or separate machines (_vertical cluster_) or in a mixed machine configuration.

Internally, a Spark executor is backed by a thread pool to run tasks.

Each executor can run multiple tasks over its lifetime, both parallel and sequentially.

It’s recommended to have as many executors as data nodes and as many cores as you can get from the cluster.

.FIXME Diagram of Spark architecture

Master/slave architecture of Spark in cluster:

* *driver* coordinates workers and execution. The driver is the process that launches the `main` method of your Spark application. It splits Spark applications into tasks and schedules them to run on the available executors.
* *executors* are distributed workers that run tasks for a Spark *job*. They typically run for the entire lifetime of the Spark application. They communicate with the driver to send computation results back. Executors provide in-memory storage for RDDs that are cached in Spark applications (via link:spark-blockmanager.adoc[Block Manager]).

When executors are started they register themselves with the driver and communicate directly to launch jobs (as tasks).

[CAUTION]
====
FIXME

* How many executors are spawned per worker?
* How many cores are assigned per executor?
====

=== Executors

An executor has its own id, hostname, classpath, environment (as `SparkEnv`), and whether it runs in link:spark-local.adoc[local] or cluster mode (aka `isLocal`).

When an executor is started the following message is printed out in the logs:

```
INFO Executor: Starting executor ID [executorId] on host [executorHostname]
INFO Executor: Using REPL class URI: http://192.168.1.4:56131
```

TIP: Enable `INFO` logging level for `org.apache.spark.executor.Executor` logger to see what happens under the hood in executors.

Executors use daemon cached thread pools for sending metrics and execute tasks.

==== driver-heartbeater - heartbeats and partial metrics for active tasks

`driver-heartbeater` daemon single-thread scheduled pool executor, i.e. `ScheduledThreadPoolExecutor`, is used for sending executor heartbeats and partial metrics for running tasks back to the driver. They are sent to the driver every `spark.executor.heartbeatInterval` (default: `10s`).

The structure with the information is an array of `(Long, TaskMetrics)`.

[CAUTION]
====
FIXME

* What's in `taskRunner.task.metrics`?
* What's in `Heartbeat`? Why is `blockManagerId` sent?
* What's in `RpcUtils.makeDriverRef`?
====

It creates an RPC endpoint for receiving RPCs from the driver.

FIXME How to know the available endpoints?

`spark.executor.userClassPathFirst` (default: `false`) controls whether to load classes in user jars before those in Spark jars.

=== [[executor-backends]] Executor backends (and schedulers)

An *executor backend* manages a single executor. At startup, it connects to the driver and creates an executor. It then launches and kills tasks. It stops when the driver orders so.

An executor backend acts as a bridge between the driver and an executor, i.e. there are two endpoints.

It asks the driver for the driver's Spark properties

TIP: Enable `INFO` for `org.apache.spark.executor.CoarseGrainedExecutorBackend` to see the inner-workings.

There are the following kinds of executor backends:

* local executor backend
* <<coarse-grained, coarse-grained executor backend>>
** used for YARN and coarse-grained mode in Mesos
* Mesos executor backend

=== Others

* *execution plan* - starts with the earliest RDDs (those with no dependencies on other RDDs or reference cached data) and ends with the RDD that produces the result of the action that has been called to execute.

* *tasks* - individual units of physical execution (computation) that run on a single machine for parts of your Spark application on a data. All tasks in a stage should be completed before moving on to another stage.
