== RDD - Resilient Distributed Dataset

=== Introduction

.The origins of RDD
****
The original paper that gave birth to the concept of RDD is https://www.cs.berkeley.edu/~matei/papers/2012/nsdi_spark.pdf[Resilient Distributed Datasets: A Fault-Tolerant Abstraction for In-Memory Cluster Computing] by Matei Zaharia, et al.
****

*Resilient Distributed Dataset (RDD)* is the primary data abstraction in Spark. It is a distributed collection of items. It is the bread and butter of Spark, and mastering the concept is of utmost importance to become a Spark pro. _And you wanna be a Spark pro, don't you?_

With RDD the creators of Spark managed to hide data partitioning and so distribution that in turn allowed them to design parallel computational framework with a higher-level programming interface (API) for four mainstream programming languages.

Learning about RDD by its name:

* *Resilient*, i.e. fault-tolerant and so able to recompute missing or damaged partitions on node failures with the help of <<lineage, RDD lineage graph>>.
* *Distributed* across link:spark-cluster.adoc[clusters].
* *Dataset* is a collection of link:spark-rdd-partitions.adoc[partitioned data].

.RDDs
image::diagrams/spark-rdds.png[align="center"]

From the scaladoc of http://spark.apache.org/docs/latest/api/scala/index.html#org.apache.spark.rdd.RDD[org.apache.spark.rdd.RDD]:

> A Resilient Distributed Dataset (RDD), the basic abstraction in Spark. Represents an immutable, partitioned collection of elements that can be operated on in parallel.

From the original paper about RDD - https://www.cs.berkeley.edu/~matei/papers/2012/nsdi_spark.pdf[Resilient Distributed Datasets: A Fault-Tolerant Abstraction for In-Memory Cluster Computing]:

> Resilient Distributed Datasets (RDDs) are a distributed memory abstraction that lets programmers perform in-memory computations on large clusters in a
fault-tolerant manner.

Beside the above traits (that are directly embedded in the name of the data abstraction - RDD) it has the following additional traits:

* *Immutable*, i.e. it does not change once created.
* *Lazy evaluated*, i.e. the data inside RDD is not available or transformed until an action is executed that triggers the execution.
* *Cacheable*, i.e. you can hold all the data in a persistent "storage" like memory (default and the most preferred) or disk (the least preferred due to access speed).
* *Parallel*, i.e. process data in parallel.

RDDs are distributed by design and to achieve even *data distribution* as well as leverage link:spark-data-locality.adoc[data locality] (in distributed systems like HDFS or Cassandra in which data is partitioned by default), they are *partitioned* to a fixed number of link:spark-rdd-partitions.adoc[partitions] - logical chunks (parts) of data. The logical division is for processing only and internally it is not divided whatsoever. Each partition comprises of *records*.

.RDDs
image::diagrams/spark-rdd-partitioned-distributed.png[align="center"]

link:spark-rdd-partitions.adoc[Partitions are the units of parallelism]. You can control the number of partitions of a RDD using `repartition` or `coalesce` operations. Spark tries to be as close to data as possible without wasting time to send data across network by means of link:spark-rdd-shuffle.adoc[RDD shuffling], and creates as many partitions as required to follow the storage layout and thus optimize data access. It leads to a one-to-one mapping between (physical) data in distributed data storage, e.g. HDFS or Cassandra, and partitions.

RDDs support two kinds of operations:

* <<transformations, transformations>> - lazy operations that return another RDD.
* <<actions, actions>> - operations that trigger computation and return values.

The motivation to create RDD were (https://www.cs.berkeley.edu/~matei/papers/2012/nsdi_spark.pdf[after the authors]) two types of applications that current computing frameworks handle inefficiently:

* *iterative algorithms* in machine learning and graph computations.
* *interactive data mining tools* as ad-hoc queries on the same dataset.

The goal is to reuse intermediate in-memory results across multiple data-intensive workloads with no need for copying large amounts of data over the
network.

Each RDD is characterized by five main properties:

* An array of link:spark-rdd-partitions.adoc[partitions] that a dataset is divided to
* A function to do a computation for a partition
* List of link:spark-rdd-dependencies.adoc[parent RDDs]
* An optional link:spark-rdd-partitions.adoc#partitioner[partitioner] that defines how keys are hashed, and the pairs partitioned (for key-value RDDs)
* Optional <<preferred-locations, preferred locations>>, i.e. hosts for a partition where the data will have been loaded.

This RDD abstraction supports an expressive set of operations without having to modify scheduler for each one.

An RDD is a named (by *name*) and uniquely identified (by *id*) entity inside a link:spark-sparkcontext.adoc[SparkContext].
It lives in a SparkContext and as a SparkContext creates a logical boundary, RDDs can't be shared between SparkContexts (see link:spark-sparkcontext.adoc#sparkcontext-and-rdd[SparkContext and RDDs]).

An RDD can optionally have a friendly name accessible using `name` that can be changed using `=`:


```
scala> val ns = sc.parallelize(0 to 10)
ns: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[2] at parallelize at <console>:24

scala> ns.id
res0: Int = 2

scala> ns.name
res1: String = null

scala> ns.name = "Friendly name"
ns.name: String = Friendly name

scala> ns.name
res2: String = Friendly name

scala> ns.toDebugString
res3: String = (8) Friendly name ParallelCollectionRDD[2] at parallelize at <console>:24 []
```

RDDs are a container of instructions on how to materialize big (arrays of) distributed data, and how to split it into partitions so Spark (using link:spark-executor.adoc[executors]) can hold some of them.

In general, data distribution can help executing processing in parallel so a task processes a chunk of data that it could eventually keep in memory.

Spark does jobs in parallel, and RDDs are split into partitions to be processed and written in parallel. Inside a partition, data is processed sequentially.

Saving partitions results in part-files instead of one single file (unless there is a single partition).

=== [[rdd-types]] Types of RDDs

There are some of the most interesting types of RDDs:

* link:spark-rdd-parallelcollectionrdd.adoc[ParallelCollectionRDD]
* link:spark-rdd-cogroupedrdd.adoc[CoGroupedRDD]
* link:spark-rdd-hadooprdd.adoc[HadoopRDD] is an RDD that provides core functionality for reading data stored in HDFS using the older MapReduce API. The most notable use case is the return RDD of `SparkContext.textFile`.
* *MapPartitionsRDD* - a result of calling operations like `map`, `flatMap`, `filter`, link:spark-rdd-operators-mapPartitions.adoc[mapPartitions], etc.
* *CoalescedRDD* - a result of calling operations like `repartition` and `coalesce`
* link:spark-rdd-shuffledrdd.adoc[ShuffledRDD] - a result of shuffling, e.g. after `repartition` and `coalesce`
* *PipedRDD* - an RDD created by piping elements to a forked external process.
* *PairRDD* (implicit conversion as `org.apache.spark.rdd.PairRDDFunctions`) that is an RDD of key-value pairs that is a result of `groupByKey` and `join` operations.
* *DoubleRDD* (implicit conversion as `org.apache.spark.rdd.DoubleRDDFunctions`) that is an RDD of `Double` type.
* *SequenceFileRDD* (implicit conversion as `org.apache.spark.rdd.SequenceFileRDDFunctions`) that is an RDD that can be saved as a `SequenceFile`.

Appropriate operations of a given RDD type are automatically available on a RDD of the right type, e.g. `RDD[(Int, Int)]`, through implicit conversion in Scala.

=== [[transformations]] Transformations

A *transformation* is a lazy operation on a RDD that returns another RDD, like `map`, `flatMap`, `filter`, `reduceByKey`, `join`, `cogroup`, etc.

Go in-depth in the section link:spark-rdd-operations.adoc#transformations[Transformations] in link:spark-rdd-operations.adoc[Operations - Transformations and Actions].

=== [[actions]] Actions

An *action* is an operation that triggers execution of <<transformations, RDD transformations>> and returns a value (to a Spark driver - the user program).

Go in-depth in the section link:spark-rdd-operations.adoc#actions[Actions] in link:spark-rdd-operations.adoc[Operations - Transformations and Actions].

=== [[creating-rdds]] Creating RDDs

==== SparkContext.parallelize

One way to create a RDD is with `SparkContext.parallelize` method. It accepts a collection of elements as shown below (`sc` is a SparkContext instance):

```
scala> val rdd = sc.parallelize(1 to 1000)
rdd: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[0] at parallelize at <console>:25
```

You may also want to randomize the sample data:

```
scala> val data = Seq.fill(10)(util.Random.nextInt)
data: Seq[Int] = List(-964985204, 1662791, -1820544313, -383666422, -111039198, 310967683, 1114081267, 1244509086, 1797452433, 124035586)

scala> val rdd = sc.parallelize(data)
rdd: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[0] at parallelize at <console>:29
```

Given the reason to use Spark to process more data than your own laptop could handle, `SparkContext.parallelize` is mainly used to learn Spark in the Spark shell. `SparkContext.parallelize` requires all the data to be available on a single machine - the Spark driver - that eventually hits the limits of your laptop.

==== SparkContext.makeRDD

CAUTION: FIXME What's the use case for `makeRDD`?

```
scala> sc.makeRDD(0 to 1000)
res0: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[1] at makeRDD at <console>:25
```

==== SparkContext.textFile

One of the easiest ways to create an RDD is to use `SparkContext.textFile` to read files. You can use the local `README.md` file (and then `map` it over to have an RDD of sequences of words):

```
scala> val words = sc.textFile("README.md").flatMap(_.split("\\s+")).cache()
words: org.apache.spark.rdd.RDD[String] = MapPartitionsRDD[27] at flatMap at <console>:24
```

NOTE: You `cache()` it so the computation is not performed every time you work with `words`.

==== [[creating-rdds-from-input]] Creating RDDs from Input

Refer to link:spark-io.adoc[Using Input and Output (I/O)] to learn about the IO API to create RDDs.

==== Transformations

RDD transformations by definition transform an RDD into another RDD and hance are the way to create new ones.

Refer to <<transformations, Transformations>> section to learn more.

=== RDDs in Web UI

It is quite informative to look at RDDs in the Web UI that is at http://localhost:4040 for link:spark-shell.adoc[Spark shell].

Execute the following Spark application (type all the lines in `spark-shell`):

[source,scala]
----
val ints = sc.parallelize(1 to 100) // <1>
ints.setName("Hundred ints")        // <2>
ints.cache                          // <3>
ints.count                          // <4>
----
<1> Creates an RDD with hundreds of numbers (with as many partitions as possible)
<2> Sets the name of the RDD
<3> Caches the RDD (so it shows up in Storage in UI)
<4> Executes action (and materializes the RDD)

With the above executed, you should see the following in the Web UI:

.RDD with custom name
image::images/spark-ui-rdd-name.png[]

Click the name of the RDD (under *RDD Name*) and you will get the details of how the RDD is cached.

.RDD Storage Info
image::images/spark-ui-storage-hundred-ints.png[]

Execute the following Spark job and you will see how the number of partitions decreases.

```
ints.repartition(2).count
```

.Number of tasks after repartition
image::images/spark-ui-repartition-2.png[]

=== Computing Partition of RDD (using compute method)

The `RDD` abstract class defines abstract `compute(split: Partition, context: TaskContext): Iterator[T]` method that computes a given `split` link:spark-rdd-partitions.adoc[partition] to produce a collection of values.

It has to be implemented by any type of RDD in Spark and is called unless RDD is link:spark-rdd-checkpointing.adoc[checkpointed] (and the result can be read from a checkpoint).

When an RDD is link:spark-rdd-caching.adoc[cached], for specified link:spark-rdd-caching.adoc#StorageLevel[storage levels] (i.e. all but `NONE`) link:spark-cachemanager.adoc[CacheManager] is requested to get or compute partitions.

`compute` method runs on a link:spark-driver.adoc[driver].

=== [[preferred-locations]] Preferred Locations

A *preferred location* (aka _locality preferences_ or _placement preferences_) is a block location for an HDFS file where to compute each partition on.

`def getPreferredLocations(split: Partition): Seq[String]` specifies placement preferences for a partition in an RDD.

=== [[lineage]] RDD Lineage Graph

A *RDD Lineage Graph* (aka _RDD operator graph_) is a graph of the parent RDDs of a RDD. It is built as a result of applying transformations to the RDD.

NOTE: The following diagram uses `cartesian` or `zip` for learning purposes only. You may use other operators to build a RDD graph. 

.RDD lineage
image::images/rdd-lineage.png[align="center"]

The above RDD graph could be the result of the following series of transformations:

```
val r00 = sc.parallelize(0 to 9)
val r01 = sc.parallelize(0 to 90 by 10)
val r10 = r00 cartesian r01
val r11 = r00.map(n => (n, n))
val r12 = r00 zip r01
val r13 = r01.keyBy(_ / 20)
val r20 = Seq(r11, r12, r13).foldLeft(r10)(_ union _)
```

A RDD lineage graph is hence a graph of what transformations need to be executed after an action has been called.

You can learn about a RDD lineage graph using <<toDebugString, RDD.toDebugString>> method.

==== [[toDebugString]] toDebugString

You can learn about a <<lineage, RDD lineage graph>> using `RDD.toDebugString` method.

```
scala> val wordsCount = sc.textFile("README.md").flatMap(_.split("\\s+")).map((_, 1)).reduceByKey(_ + _)
wordsCount: org.apache.spark.rdd.RDD[(String, Int)] = ShuffledRDD[24] at reduceByKey at <console>:24

scala> wordsCount.toDebugString
res2: String =
(2) ShuffledRDD[24] at reduceByKey at <console>:24 []
 +-(2) MapPartitionsRDD[23] at map at <console>:24 []
    |  MapPartitionsRDD[22] at flatMap at <console>:24 []
    |  MapPartitionsRDD[21] at textFile at <console>:24 []
    |  README.md HadoopRDD[20] at textFile at <console>:24 []
```

==== [[spark.logLineage]] spark.logLineage

Enable `spark.logLineage` (assumed: `false`) to see a RDD lineage graph using <<toDebugString, RDD.toDebugString>> method every time an action on a RDD is called.

```
$ ./bin/spark-shell -c spark.logLineage=true

scala> sc.textFile("README.md", 4).count
...
15/10/17 14:46:42 INFO SparkContext: Starting job: count at <console>:25
15/10/17 14:46:42 INFO SparkContext: RDD's recursive dependencies:
(4) MapPartitionsRDD[1] at textFile at <console>:25 []
 |  README.md HadoopRDD[0] at textFile at <console>:25 []
```

=== [[execution-plan]] Execution Plan

*Execution Plan* starts with the earliest RDDs (those with no dependencies on other RDDs or reference cached data) and ends with the RDD that produces the result of the action that has been called to execute.
