== RDD - Resilient Distributed Dataset

=== Introduction

.The origins of RDD
****
The original paper that gave birth to the concept of RDD is https://www.cs.berkeley.edu/~matei/papers/2012/nsdi_spark.pdf[Resilient Distributed Datasets: A Fault-Tolerant Abstraction for In-Memory Cluster Computing] by Matei Zaharia, et al.
****

*Resilient Distributed Dataset (RDD)* is the main data abstraction in Spark. It is simply the bread and butter of Spark. With RDD the creators of Spark managed to hide data partitioning and distribution that in turn allowed them to design parallel computational framework with a higher-level programming interface (API).

TIP: Learn the concept of RDD in depth and you understand Spark to become a professional Spark developer.

Learning about RDD from its name:

* *Resilient*, i.e. fault-tolerant and so able to recompute missing or damaged partitions on node failures with the help of <<lineage, RDD Lineage>>.
* *Distributed* across link:spark-cluster.adoc[clusters].
* *Dataset* is a collection of link:spark-rdd-partitions.adoc[partitioned data].

From the scaladoc of http://spark.apache.org/docs/latest/api/scala/index.html#org.apache.spark.rdd.RDD[org.apache.spark.rdd.RDD]:

> A Resilient Distributed Dataset (RDD), the basic abstraction in Spark. Represents an immutable, partitioned collection of elements that can be operated on in parallel.

From the original paper about RDD - https://www.cs.berkeley.edu/~matei/papers/2012/nsdi_spark.pdf[Resilient Distributed Datasets: A Fault-Tolerant Abstraction for In-Memory Cluster Computing]:

> Resilient Distributed Datasets (RDDs) are a distributed memory abstraction that lets programmers perform in-memory computations on large clusters in a
fault-tolerant manner.

Beside the above traits (that are directly embedded in the name of the data abstraction - RDD) it has the following additional traits:

* *Immutable*, i.e. it does not change once created.
* *Lazy evaluated*, i.e. the data inside RDD is not available or transformed until an action is executed that triggers the execution.
* *Cacheable*, i.e. you can hold all the data in a persistent "storage" like memory (default and the most preferred) or disk (the least preferred due to access speed).
* *Parallel*, i.e. process data in parallel.

RDDs are distributed by definition and to achieve even *data distribution* as well as leverage link:spark-data-locality.adoc[data locality] (in distributed systems like HDFS or Cassandra in which data is partitioned by default), they are *partitioned* to a fixed number of link:spark-rdd-partitions.adoc[partitions] that are logical chunks (parts) of data. The logical division is for processing only and internally it is not divided whatsoever. Each partition comprises of a number of *records*.

link:spark-rdd-partitions.adoc[Partitions are the units of parallelism]. You can control the number of partitions of a RDD using `repartition` or `coalesce` operations. Spark tries to be as close to data as possible without wasting time to send data across network, i.e. link:spark-rdd-shuffle.adoc[RDD shuffling], and creates as many partitions as required to follow the storage layout to optimize data access. It leads to a one-to-one mapping between (physical) data in HDFS or Cassandra and partitions.

The motivation to create RDD were (https://www.cs.berkeley.edu/~matei/papers/2012/nsdi_spark.pdf[after the authors]) two types of applications that current computing frameworks handle inefficiently:

* *iterative algorithms* in machine learning and graph computations.
* *interactive data mining tools* as ad-hoc queries on the same dataset.

The goal is to reuse intermediate in-memory results across multiple data-intensive workloads with no need for copying large amounts of data over the
network.

Internally, each RDD is characterized by five main properties:

* Partitions
* A function to compute splits
* Dependencies on other RDDs
* Optionally, a Partitioner for key-value RDDs
* Optionally, a list of preferred locations to compute each split on, e.g. block locations for an HDFS file

RDDs are a container of instructions on how to materialize big (arrays of) distributed data, and how to split it into partitions so Spark (using *executors*) can hold some of them.

In general, data distribution can help executing processing in parallel so a task processes a chunk of data that it could eventually keep in memory.

Increasing partitions count will make each partition to have less data.

Spark does jobs in parallel, and RDDs are split into partitions to be processed and written in parallel. Inside a partition, data is processed sequentially.

Saving partitions results in part-files instead of one single file (unless there is a single partition).

=== Types of RDDs

There are four types of RDDs:

* `PairRDD` (implicit conversion as `org.apache.spark.rdd.PairRDDFunctions`) that is an RDD of key-value pairs that is a result of `groupByKey` and `join` operations.
* `DoubleRDD` (implicit conversion as `org.apache.spark.rdd.DoubleRDDFunctions`) that is an RDD of `Double` type.
* `SequenceFileRDD` (implicit conversion as `org.apache.spark.rdd.SequenceFileRDDFunctions`) that is an RDD that can be saved as a `SequenceFile`.
* The other non-specialized RDD.

Appropriate operations of a given RDD type are automatically available on a RDD of the right type, e.g. `RDD[(Int, Int)]`, through implicit conversion in Scala.

=== [[transformations]] Transformations

A *transformation* is a lazy operation on a RDD that returns another RDD, e.g. `RDD.flatMap`.

[source,scala]
----
scala> val words = lines.flatMap(_.split("\\s+"))
words: org.apache.spark.rdd.RDD[String] = MapPartitionsRDD[27] at flatMap at <console>:26
----

Transformations do nothing until an action executes and triggers execution.

There are two types of transformations:

* *narrow transformations* - the result of `map`, `filter` and such that is from the data from a single partition only, i.e. it is self-sustained.
+
An output RDD has partitions with records that originate from a single partition in the parent RDD. Only a limited subset of partitions used to calculate the result.
+
Spark groups narrow transformations as a stage.
* *wide transformations* - the result of `groupByKey` and `reduceByKey`. The data required to compute the records in a single partition may reside in many partitions of the parent RDD.
+
All of the tuples with the same key must end up in the same partition, processed by the same task. To satisfy these operations, Spark must execute link:spark-rdd-shuffle.adoc[RDD shuffling], which transfers data across cluster and results in a new stage with a new set of partitions.

Transformation operations:

* `map`
* `filter`
* `flatMap`
* `reduceByKey`
* `join`
* `cogroup`

=== [[actions]] Actions

An *action* triggers execution of <<transformations, RDD transformations>> and returns a value (to a Spark driver).

You can think of actions as a valve and until no action is fired, the data to be processed is not even in the pipes, i.e. transformations. They are only actions to materialize the entire processing pipeline with real data.

Action operations:

* `count`
* `reduce`
* `collect`
* `take`
* `first`
* `saveAsTextFile`
* `saveAsHadoopFile`
* `countByValue`

Internally, actions launch *jobs* (on all partitions of an RDD) to return a value to the user program.

[source,scala]
----
scala> words.count  // <1>
res0: Long = 502
----
<1> `words` is an RDD of `String`.

TIP: You should `cache` an RDD you work with when you want to execute two or more actions on it for better performance. Refer to link:spark-rdd-caching.adoc[RDD Caching / Persistence].

Before calling an action, Spark does closure/function cleaning (using `SparkContext.clean`) to make it ready to be serialized and send to tasks.

NOTE: Spark uses `ClosureCleaner` to clean closures.

Refer to link:spark-execution-model.adoc[Spark Execution Model] to learn the low-level details of actions.

=== Creating RDDs

==== SparkContext.parallelize

One way to create a RDD is with `SparkContext.parallelize` method. It accepts a collection of elements as shown below (`sc` is a SparkContext instance):

```
scala> val rdd = sc.parallelize(1 to 1000)
rdd: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[0] at parallelize at <console>:25
```

You may also want to randomize the sample data:

```
scala> import util.Random._
import util.Random._

scala> val data = Seq.fill(10000)(nextInt)
data: Seq[Int] = List(-964985204, 1662791, -1820544313, -383666422, -111039198, 310967683, 1114081267, 1244509086, 1797452433, 124035586, -1958994392, 742052111, 1132419282, 574625924, -1227379875, 1562683169, 1958684764, 510513087, 2017599350, -951240527, -41146865, 742984562, -256676155, 310396389, -2054796461, 858301368, 356810964, -75690588, 1437162625, 904783265, 1039779681, 1859531336, -552926847, 1799907582, 1680982441, 1654568338, -1328593741, 1392570235, 1986129897, 911622110, 1403755538, -1943363341, 1018231585, 687220375, -869343081, -1103415041, -1381690086, 220456428, -142157861, -1375733296, -1609968470, -1834679869, -421383169, -798066626, 1604391479, 1031504366, 1175989711, -441608928, 1902545017, -439255652, -1725096667, 2141468638, 1919303043, -2092078575, 870167435, -...

scala> val rdd = sc.parallelize(data)
rdd: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[0] at parallelize at <console>:29
```

Given the reason to use Spark to process more data than your own laptop could handle, `SparkContext.parallelize` is mainly used to learn Spark in the Spark shell. `SparkContext.parallelize` requires all the data to be available on a single machine - the Spark driver - that eventually hits the limits of your laptop.

==== SparkContext.makeRDD

CAUTION: FIXME What's the use case for `makeRDD`?

```
scala> sc.makeRDD(0 to 1000)
res0: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[1] at makeRDD at <console>:25
```

==== SparkContext.textFile

One of the easiest ways to create an RDD is to use `SparkContext.textFile` to read files. You can use the local `README.md` file (and then `map` it over to have an RDD of sequences of words):

```
scala> val words = sc.textFile("README.md").flatMap(_.split("\\s+")).cache()
words: org.apache.spark.rdd.RDD[String] = MapPartitionsRDD[27] at flatMap at <console>:24
```

NOTE: You `cache()` it so the computation is not performed every time you work with `words`.

Refer to link:spark-files.adoc[Using Files] to learn about creating RDDs out of files.

==== Transformations

RDD transformations by definition transform an RDD into another RDD and hance are the way to create new ones.

Refer to <<transformations, Transformations>> section to learn more.

=== RDDs in Web UI

It is quite informative to look at RDDs in the Web UI that is at http://localhost:4040 for link:spark-shell.adoc[Spark shell].

Execute the following Spark application (type all the lines in `spark-shell`):

[source,scala]
----
val ints = sc.parallelize(1 to 100) // <1>
ints.setName("Hundred ints")        // <2>
ints.cache                          // <3>
ints.count                          // <4>
----
<1> Creates an RDD with hundreds of numbers (with as many partitions as possible)
<2> Sets the name of the RDD
<3> Caches the RDD (so it shows up in Storage in UI)
<4> Executes action (and materializes the RDD)

With the above executed, you should see the following in the Web UI:

.RDD with custom name
image::images/spark-ui-rdd-name.png[]

Click the name of the RDD (under *RDD Name*) and you will get the details of how the RDD is cached.

.RDD Storage Info
image::images/spark-ui-storage-hundred-ints.png[]

Execute the following Spark job and you will see how the number of partitions decreases.

```
ints.repartition(2).count
```

.Number of tasks after repartition
image::images/spark-ui-repartition-2.png[]

=== Internals of RDDs

* `compute(split: Partition, context: TaskContext): Iterator[T]` computes a given link:spark-rdd-partitions.adoc[RDD partition]. It is implemented by any RDD in Spark.
** Called unless RDD is link:spark-rdd-checkpointing.adoc[checkpointed].
* `def getPartitions: Array[Partition]` returns the set of partitions in this RDD.
* `def getDependencies: Seq[Dependency[_]]` returns how this RDD depends on parent RDDs.
+
```
scala> lines.dependencies
res3: Seq[org.apache.spark.Dependency[_]] = List(org.apache.spark.OneToOneDependency@56d5a50f)
```
* `def getPreferredLocations(split: Partition): Seq[String]` specifies placement preferences.
* `val partitioner: Option[Partitioner]` specifies how they are partitioned (FIXME: Who is _they_?)

=== [[lineage]] RDD Lineage

==== toDebugString

```
scala> val wordsCount = sc.textFile("README.md").flatMap(_.split("\\s+")).map((_, 1)).reduceByKey(_ + _)
wordsCount: org.apache.spark.rdd.RDD[(String, Int)] = ShuffledRDD[24] at reduceByKey at <console>:24

scala> wordsCount.toDebugString
res2: String =
(2) ShuffledRDD[24] at reduceByKey at <console>:24 []
 +-(2) MapPartitionsRDD[23] at map at <console>:24 []
    |  MapPartitionsRDD[22] at flatMap at <console>:24 []
    |  MapPartitionsRDD[21] at textFile at <console>:24 []
    |  README.md HadoopRDD[20] at textFile at <console>:24 []
```

==== spark.logLineage

Enable `spark.logLineage` (assumed: `false`) to see recursive dependencies of RDDs using `RDD.toDebugString` method every time an action is called.

```
$ ./bin/spark-shell --conf spark.logLineage=true
...
scala> System.getProperty("spark.logLineage")
res0: String = true

scala> sc.textFile("README.md", 4).count
...
15/10/17 14:46:42 INFO SparkContext: Starting job: count at <console>:25
15/10/17 14:46:42 INFO SparkContext: RDD's recursive dependencies:
(4) MapPartitionsRDD[1] at textFile at <console>:25 []
 |  README.md HadoopRDD[0] at textFile at <console>:25 []
```

=== Other findings

* An RDD has a unique id (within a `SparkContext`).
* An RDD can optionally have a friendly name accessible using `name` that can be changed using `def setName(_name: String)`.
* Some (all?) operations of an RDD clean computations (closures) so they are ready to be serialized and sent to tasks. Cleaning computations throws `SparkException` if computation cannot be cleaned.
